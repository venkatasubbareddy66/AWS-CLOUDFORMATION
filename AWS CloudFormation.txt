

======================================================== AWS CLOUDFORMATION =========================================================



-- CloudFormation Linter - use this extension in vs code 

-- open terminal and enter these cmnds (python need to installed before doing this)

pip3 install cfn-lint
pip3 install pydot






======================================================== 1 Cloud Formation Introdution ======================================================== 


-- use us-east-1 region for cloudformation

-- we're going to create a simple EC2 instance.

-- We're going to add a security group to it.

-- create one yaml file 


intro.yaml


Resources:
  MyInstance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: us-east-1a
      ImageId: ami-0ebfd941bbafe70c6
      InstanceType: t2.micro



-- upload this file in CF 

-- this template will get create ec2 instance for you 

-- now update the template with the following code 





Resources:
  MyInstance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: us-east-1a
      ImageId: ami-0742b4e673072066f
      InstanceType: t2.micro
      SecurityGroups:
        - !Ref SSHSecurityGroup
        - !Ref ServerSecurityGroup

  # an elastic IP for our instance
  MyEIP:
    Type: AWS::EC2::EIP
    Properties:
      InstanceId: !Ref MyInstance

  # our EC2 security group
  SSHSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access via port 22
      SecurityGroupIngress:
      - CidrIp: 0.0.0.0/0
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22

  # our second EC2 security group
  ServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: allow connections from specified CIDR ranges
      SecurityGroupIngress:
      - IpProtocol: tcp
        FromPort: 80
        ToPort: 80
        CidrIp: 0.0.0.0/0
      - IpProtocol: tcp
        FromPort: 22
        ToPort: 22
        CidrIp: 192.168.1.1/32




-- Changeset preview   ----> to know the Changes

-- this will create new instance and terminate old instance , So the idea here is that CloudFormation has determined that to apply the updates. It needed to create a new EC2 instance and terminate the old one.

-- now observe the changes and delete the stack once u done








======================================================== 2 Cloud Formation Getting Started ======================================================== 





-- if you have code in json , if you want to convert from json to yaml , u can try on this website 


https://www.json2yaml.com/ 





----------------------------------- create s3 bucket using CF




-- try to create bucket using cfn


Resources:
  MyS3Bucket:
    Type: AWS::S3::Bucket
    Properties: {}



-- upload this code and it will create bucket for you 

-- here  Properties: {}  , so we are providing any Properties so open and close brackets , we wont get any error

-- there's a bucket named string, if you do not specify it, then you will get a random bucket name.






----------------------------------- Update the s3 bucket using CF 



-- So before we update our stack, let's talk about the CloudFormation update behavior.

-- So CloudFormation updates resources based on differences between what you submit and the stack's current template.

-- So we'll look at where there's change and do the necessary updates.

-- The method of how it does it's updates depends on the property you have changed for a specific resource.


---------------------- IMP to know



-- you have three kinds of changes that can happen in CloudFormation.

      1 There is an updates with no interruption :
            
            - That means that it doesn't disrupt the resources operations and it doesn't change the physical ID of your resources.

            - For example, if you are updating the IAM instance profile of an EC2 instance, this is something you can do in the console without stopping  your EC2 instance and so can you while using CloudFormation.
    
      2 Update with some interruption :

            - for example, an EC2 instance being stopped. Well, if we change the instance type of our EC2 instance from a t2.micro to t2.large. It requires it to be stopped and then restarted,

            - so this is why it's called update with some interruption.

      3 replacements :

            - Replacements means that you have to recreate a new resource with a new physical ID, because the properties you have changed do not match with the current stack states.   

            - so therefor, the new resource will be created, the references will be changed from other resources to the new resource,and then the older resources will be deleted.

            - For example, if you change the availability zone of an RDS database instance, then the previous one will have to be deleted and the new one will have to be created.



-- we'll see more about updates and how we can maybe save some of these objects or prevent them from being replaced.


-- we're going to update a S3 bucket. And we'll consider two types of updates.

-- We'll consider the updates with no interruption by adding some Access Control.

-- And we'll also see a replacement updates by updating the name of the S3 buckets.

-- So let's have a look to see how CloudFormation reacts in both these cases.


https://repost.aws/knowledge-center/cloudformation-objectownership-acl-error    - REF 





AWSTemplateFormatVersion: "2010-09-09"

Resources:
  PortalBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: LogDeliveryWrite
      VersioningConfiguration:
        Status: Enabled
      WebsiteConfiguration:
        IndexDocument: 'index.html'
        ErrorDocument: 'error.html'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      OwnershipControls:
        Rules:
          - ObjectOwnership: ObjectWriter


-- This allows you to activate ACLs on the bucket.


-- now let's update and upload this templates and see what happens.

-- now change the bucket name the update requires a replacement. so make sure that your S3 bucket has zero objects.

-- this one will be deleted and a new one will be created.




Resources:
  PortalBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: LogDeliveryWrite
      VersioningConfiguration:
        Status: Enabled
      WebsiteConfiguration:
        IndexDocument: 'index.html'
        ErrorDocument: 'error.html'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      OwnershipControls:
        Rules:
          - ObjectOwnership: ObjectWriter
      BucketName: "insert-some-random-string-here-123452433"





-- upload this code and see in CF console

-- in Changeset preview , u can see that replacement = true 

-- there is my S3 bucket that is going to create a new physical resource,

-- once that S3 bucket is created, the other one that we have from right here will be deleted.

-- delete the stack , make sure no objects in s3 bucket









----------------------------------- CloudFormation template options



-- So there's a lot of options you can do when you upload a CloudFormation template.

    - Tags : 
    
         when we specify a tag in CloudFormation these tags will be passed on to every single resource created by CloudFormation which is quite handy.

    - Permissions: 
     
         Permissions is for us to be able to specify an IAM role to create all the resources within CloudFormation.

    - Notification options : 
    
         Notification options is to receive all these events around how your CloudFormation stack is doing to an SNS topic.

    - Timeout :
    
         is to say how long you're willing to wait before declaring that the CloudFormation templates, that creation has failed.
     
    - Roll back on failure:

         Roll back on failure is allowing you to not being able to delete your resources, if in case they're not being created correctly

    - Rollback configuration:

         Rollback configuration which is allowing you to set up a time or a specific Cloudwatch alarm 

    - Termination protection:

         Termination protection is a way for you to disable the deletion of your CloudFormation template accidentally.     





----------------------------------- CloudFormation – Building Blocks


• Template’s Components

        • AWSTemplateFormatVersion – identifies the capabilities of the template “2010-09-09” • Description – comments about the template

        • Resources (MANDATORY) – your AWS resources declared in the template

        • Parameters – the dynamic inputs for your template

        • Mappings – the static variables for your template

        • Outputs – references to what has been created

        • Conditionals – list of conditions to perform resource creation
    
 




----------------------------------- Deploying CloudFormationTemplates



• Manual way

    • Editing templates in Application Composer or code editor
    • Using the console to input parameters, etc...
    • We’ll mostly do this way in the course for learning purposes


• Automated way

    • Editing templates in a YAML file
    • Using the AWS CLI (Command Line Interface) to deploy the templates, or using a Continuous Delivery (CD) tool
    • Recommended way when you fully want to automate your flow








======================================================== CloudFormation – Parameters ======================================================== 




• Parameters are a way to provide inputs to your AWS CloudFormation template

• They’re important to know about if:

     • You want to reuse your templates across the company

     • Some inputs can not be determined ahead of time


• Parameters are extremely powerful, controlled, and can prevent errors from happening in your templates, thanks to types







-------------------------- When should you use a Parameter?


• Ask yourself this:

    • Is this CloudFormation resource configuration likely to change in the future? 
    • If so, make it a parameter






-------------------------- CloudFormation – Parameters Settings


• Parameters can be controlled by all these settings:


   • Type:
       
       • String – A literal string
       • Number – An integer or float
       • CommaDelimitedList – An array of literal strings that are separated by commas
       • List<Number> – An array of integers or floats
       • AWS-Specific Parameter (to help catch invalid values – match against existing values in the AWS account)
       • List<AWS-Specific Parameter>
       • SSM Parameter (get parameter value from SSM Parameter store)
       • Description
       • ConstraintDescription (String)
       • Min/MaxLength
       • Min/MaxValue
       • Default
       • AllowedValues (array)
       • AllowedPattern (regex)
       • NoEcho (Boolean)
       • AWS::EC2::KeyPair::KeyName – An Amazon EC2 key pair name
       • AWS::EC2::SecurityGroup::Id – A security group ID
       • AWS::EC2::Subnet::Id – A subnet ID
       • AWS::EC2::VPC::Id – A VPC ID
       • List<AWS::EC2::SecurityGroup::Id> – An array of security group IDs
       • List<AWS::EC2::Subnet::Id> – An array of subnet IDs






-------------------------- How to Reference a Parameter?


• The Fn::Ref function can be leveraged to reference parameters

• Parameters can be used anywhere in a template

Except:
  
    - TemplateFormatVersion,
    - description, 
    - transform and 
    - mappings.

• The shorthand for this inYAML is !Ref

• The function can also reference other elements within the template






------------------------------- CloudFormation – Parameters Example

     1 • AllowedValues (array)

Parameters:
 InstanceType:
   Description: Choose an ec2 type
   Type: String
   AllowedValues:
      - t2.micro
      - t3.micro
      - t2.small


Resources:
  Ec2Instance:
    Type: 'AWS::EC2::Instance'
    Properties:
       InstanceType: !Ref InstanceType
       ImageId: xxxxxxxxxxxxxx



-- Here , we have a parameter called InstanceType. To choose an EC2 InstanceType of Type: String.

-- But we have defined AllowedValues being t2.micro, t2.small, or t2.medium with a Default being t2.micro. And this parameter is reused in the EC2Instance.

-- So thanks to it, we'll have a dropdown and the user can only select one of these three values, hence giving them choice while giving you control.







     2 NoEcho (Boolean)


Parameters:
 DBPassword:
   Description: db password
   Type: String
   NoEcho: true

Resources:
  MyDBInstance:
   Type: 'AWS::RDS::DBInstance'
    Properties:
      DBInstanceClass: db.t2.microParameters
      AllocatedStorage: 20
      Engine: mysql 
      MasterUsername: administration
      MasterUserpassword: !Ref DBPassword
      DBInstanceIdentifier: MydbInstance


-- So for example, say we want as a parameter to put in the database password, but of course it is a password so we have to keep it secret.

-- So we want to remove it from the logs and so on. So we'll have NoEcho: true , so that the password is not displayed anywhere.









------------------------------- Parameters Hands on




create one yaml file like this with parameters




Parameters:
  SecurityGroupDescription:
    Description: Security Group Description (Simple parameter)
    Type: String

  SecurityGroupPort:
    Description: Simple Description of a Number Parameter, with MinValue and MaxValue
    Type: Number
    MinValue: 1150
    MaxValue: 65535

  InstanceType:
    Description: WebServer EC2 instance type (has default, AllowedValues)
    Type: String
    Default: t2.small
    AllowedValues:
      - t1.micro
      - t2.nano
      - t2.micro
      - t2.small
    ConstraintDescription: must be a valid EC2 instance type.

  DBPwd:
    NoEcho: true
    Description: The database admin account password (won't be echoed)
    Type: String

  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instances. Linked to AWS Parameter
    Type: AWS::EC2::KeyPair::KeyName
    ConstraintDescription: must be the name of an existing EC2 KeyPair.

  SecurityGroupIngressCIDR:
    Description: The IP address range that can be used to communicate to the EC2 instances
    Type: String
    MinLength: '9'
    MaxLength: '18'
    Default: 0.0.0.0/0
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})
    ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x.

  MyVPC:
    Description: VPC to operate in
    Type: AWS::EC2::VPC::Id

  MySubnetIDs:
    Description: Subnet IDs that is a List of Subnet Id
    Type: "List<AWS::EC2::Subnet::Id>"

  DbSubnetIpBlocks:
    Description: "Comma-delimited list of three CIDR blocks"
    Type: CommaDelimitedList
    Default: "10.0.48.0/24, 10.0.112.0/24, 10.0.176.0/24"

Resources:
  MyEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      #we reference the InstanceType parameter
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName
      ImageId: ami-0742b4e673072066f
      # here we reference an internal CloudFormation resource
      SubnetId: !Ref DbSubnet1

  MySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: !Ref SecurityGroupDescription
      SecurityGroupIngress:
        - CidrIp: !Ref SecurityGroupIngressCIDR
          FromPort: !Ref SecurityGroupPort
          ToPort: !Ref SecurityGroupPort
          IpProtocol: tcp
      VpcId: !Ref MyVPC

  DbSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      # the select function allows us to select across a list
      CidrBlock: !Select [0, !Ref DbSubnetIpBlocks]

  DbSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      # the select function allows us to select across a list
      CidrBlock: !Select [1, !Ref DbSubnetIpBlocks]
      
  DbSubnet3:
    Type: AWS::EC2::Subnet
    Properties:
      VpcId: !Ref MyVPC
      # the select function allows us to select across a list
      CidrBlock: !Select [2, !Ref DbSubnetIpBlocks]




Explanation: in above script we have different types of parameters 

- (\d{1,3}) = 1-3 digits 

- we can reference these parameters within our templates. check resource block

- the Ref function works equally well for parameters, as well as references

- deploy this stack and observe how it is Getting created resources





---------------------------------------- ADVANCED SSM Parameter Type



-- So let's go ahead and learn about how to use a parameter that comes from the Systems Manager Parameter Store. So it's called an SSM Parameter type.

-- So the idea is that we want to store the value of the parameter outside of your CloudFormation template in a service called the Parameter Store.

IMP -- So the value of the parameter in our CloudFormation template is going to present the key in the Parameter Store.

-- the CloudFormation will always fetch the latest value of the parameter independents or source or you can not specify a specific version.

-- CloudFormation does not store Secure String values.

-- So if you're using a parameter that is secure, then it's compatible with CloudFormation and the validation can be done on the SSM Parameter keys but you can not do a validation on the value returned by the Parameter Store.





---------------------- Example - Fetch Latest AMI ID's


-- So the idea is that when we are launching a new two instance and want to use, for example, Amazon Linux 2.

-- We know that the AMI ID does change from region to region. We know that the AMI ID does change from region to region.

-- And on top of that, the latest Amazon Linux 2 always gets updated from AWS from time to time.

-- So that means we need to update all of our templates to keep up with the latest AMI ID of the latest updates of Amazon Linux 2

-- So instead there is a Parameter in the Parameter store from AWS which does always return the latest AMI ID for your Amazon Linux 2. Then on top of it, it is going to be changing from region to region.

-- So we moved the templates and you pass in this Parameter and you do a create stack, CloudFormation will fetch the latest AMI ID from the SSM Parameter store, which will be returned and then use within your templates.






---------------------- ADVANCED SSM Parameter Type Hands On


-- create template like this 


Parameters:
  InstanceType:
    Description: WebServer EC2 instance type
    Type: AWS::SSM::Parameter::Value<String>
    Default: /dev/ec2/instanceType
    
  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Resources:
  MyEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: !Ref ImageId





-- So the first one is instance type, and we're going to specify the instance type for an EC2 instance.

-- And so the idea is that we don't want to specify the instance type directly as the parameter, but instead, we want to reference the instance type coming from the SSM parameter store

-- open parameter store in console and create parameter with the name /dev/ec2/instanceType , Tier = std , Type = string , Data type = text,value = t2.micro




-- The second parameter we have in our confirmation template is ImageID. And again, it is a type SSM parameter.

-- now and deploy the stack in CF 

-- once u upload the stacj the image id /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2  , automatically fetch latest AMI  from the public parameters store 

-- create stack , ec2 created , so everry time it will fetch latest AMI from the parameter store 

-- now chnage the value of parameter from t2.micro to t2.small , update the stack , 

-- it will take values from parameter store and update the instance type according that value , in this process the ec2 instance will get stopped and updates and sgin Started










======================================================== AWS CLOUDFORMATION RESOURCES, =========================================================




• Resources are the core of your CloudFormation template (MANDATORY)

• They represent the different AWS Components that will be created and configured

• Resources are declared and can reference each other

• AWS figures out creation, updates and deletes of resources for us

• There are over 700 types of resources (!)

• Resource types identifiers are of the form:

       service-provider::service-name::data-type-name

       EG : AWS::EC2::Volume



https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ec2-instance.html  - ref 









------------------------------------------ optional attributes for resource



- DependsOn :

    - this is a very useful one to allow to draw a dependency between two resources.

    - For example, you want to only create an ECS cluster after the underlying Auto Scaling Group is created.

- DeletionPolicy:

    - this is going to allow you to protect resources from being deleted, even if, the CloudFormation stack is deleted.

    - For example, you never want to lose an RDS database that you create through a CloudFormation stack.Then, you would add a DeletionPolicy to it.


- UpdateReplacePolicy:

    - The UpdateReplacePolicy is also similar. The system protects resources from being replaced during a CloudFormation update.

    



---------------------------------------- 1 DependsOn :


-- allows you to make sure that a resource is created after another one because they depend on each other.

• Applied automatically when using !Ref and !GetAtt

• Use with any resource



Resources:
  Ec2Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId:
        Fn::FindInMap:
        - RegionMap
        - Ref: AWS::Region
        - AMI
    DependsOn: myDB
  myDB:
    Type: AWS::RDS::DBInstance
    Properties:
      AllocatedStorage: '5'
      DBInstanceClass: db.t2.small
      Engine: MySQL
      EngineVersion: '5.5'
      MasterUsername: MyName
      MasterUserPassword: MyPassword



-- we can see that we have an EC2 instance and an RDS database instance being created. And in this example we're saying that we want the EC2 instance to depend on the database.      

-- so therefore the EC2 instance will only be created once the database itself has been successfully created.




-------------------------------- DependsOn hands On



Parameters:  
  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Resources:
  MyS3Bucket:
    Type: AWS::S3::Bucket

  # the EC2 instance will be created after the S3 bucket
  MyInstance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref ImageId
      InstanceType: t2.micro
    DependsOn: MyS3Bucket





-- the EC2 instance will only be created after the S3 bucket. And in case of a deletion, it will be deleted first and then the S3 bucket will be deleted after.

-- uplaod the stack and observe 

-- now delete the stack u can observe that First, my EC2 instance should be deleted , then the S3 bucket will be deleted.







-------------------------------- 2 DeletionPolicy



• Control what happens when the CloudFormation template is deleted or when a resource is removed from a CloudFormation template

• Extra safety measure to preserve and backup resources

• Default DeletionPolicy=Delete

      • Delete won’t work on an S3 bucket if the bucket is not empty



-- So by default, we've seen that when we delete a CloudFormation template, all the resources within are also deleted. That means that the default DeletionPolicy is delete, so you don't have to specify it because it is the default.


EG:1

Resources:
  MyInstance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: us-east-1a
      ImageId: ami-0a3c3a20c09d6f377
      InstanceType: t2.micro
    DeletionPolicy: Delete  





-------------------------------- CloudFormation – DeletionPolicy Retain


• DeletionPolicy=Retain:

      • Specify on resources to preserve in case of CloudFormation deletes

      • Works with any resources




EG :

AWSTemplateFormatVersion: '2010-09-09'
Resources:
  myS3Bucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Retain



-- So example here, we have a S3, and we know that by default, it would be deleted when I delete my CloudFormation template, 

-- but maybe we actually wanna keep it, keep the data within because we care about the data of this bucket. And so we would specify at the bottom DeletionPolicy retain.

-- And so even if I delete my CloudFormation templates, this S3 Bucket would stay, and this works with any resources.








----------------------------- 3 CloudFormation – DeletionPolicy Snapshot


• DeletionPolicy=Snapshot

• Create one final snapshot before deleting the resource

• Examples of supported resources:

    • EBS Volume, ElastiCache Cluster, ElastiCache ReplicationGroup

    • RDS DBInstance, RDS DBCluster, Redshift Cluster, Neptune DBCluster, DocumentDB DBCluster





----------- LAB 


-- create one yaml file that has DeletionPolicy


Resources:
  MySG:
    Type: AWS::EC2::SecurityGroup
    DeletionPolicy: Retain
    Properties:
      GroupDescription: Enable SSH access via port 22
      SecurityGroupIngress:
      - CidrIp: 0.0.0.0/0
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22

  MyEBS:
    Type: AWS::EC2::Volume
    DeletionPolicy: Snapshot
    Properties:
      AvailabilityZone: us-east-1a
      Size: 1
      VolumeType: gp2



-- in above example , there is a security group and the DeletionPolicy is retained. So that means that if I delete my transformation stack, this security group should stay.

-- And there is an EBS volume, and the DeletionPolicy is a snapshot. So that means that upon deleting the stack, the volume should go away, but a snapshot should be created first.

-- let's see how it is working 

-- upload yaml file and create one stack 

-- once the resource is created , do delete the stack

-- u can observe that MySG = DELETE_SKIPPED , 'coz we have given retain 

-- ebs volume is deleted but the snapshot is already created for u go n check in console 

-- u can delete manually through console , if u want to delete 









------------------------------- 3 UpdateReplacePolicy:



-- this is to control what happens to a resource if you update a property on the resource whose update behavior is Replacement.

-- For example, if you have a database instance and you change the availabilities on property then it's going to be replaced entirely.

-- this can be used with any kind of resource.

1 By default the UpdateReplacePolicy = delete:

         - that means that CloudFormation will delete the old resource and create a new one with a new physical ID and we have observed that behavior in the past,

-- but we can also set Update Replace Policy to retain. In this case, the old resource will be retained and removed from CloudFormation's scope and then a new resource will be created.         

2 UpdateReplacePolicy = Retain:

         - keeps the resource

3 UpdateReplacePolicy = Snapshot:

         - the snapshot itself that is created, as of this update, is not within CloudFormation's scope.

         - It exists, but it will not appear as a resource within your CloudFormation template.






------------------------------- what is the difference between a Deletion Policy and an Update Replace Policy?



-- Well, they go actually hand-in-hand together.

-- So the Update Replace Policy only applies to resources that are being replaced during a stack update,so this applies to stacks update,

-- while a deletion policy applies to resources deleted when a stack is deleted or when the resource definition is removed and therefore the underlying resource is deleted.

-- So they go hand-in-hand together and you then must use both if you want to protect a resource entirely,





----------------------------- hands On for both




Parameters:
  BucketName:
    Type: String

Resources:
  MyS3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref BucketName
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain





-- create stack and it will create s3 bucket 

-- now update the stack and observe

-- then there is no deletion of the previous resource because of the update replace policy

-- so that means that both my buckets exist.

-- but for the management of the buckets under CloudFormation only the latest one is referenced. The previous one is just removed from the scope of CloudFormation.

-- if I delete my stack

-- which also has, by the way, a deletion policy of Retain

-- so both my buckets are going to be retained and the previous one will not be deleted either.

-- So we would need to manually delete them ourself.








----------------------------- CloudFormation – Resources FAQ


• Can I create a dynamic number of resources?

         - For example, you say, hey, I want to create four S3 buckets at a time.

         - Yes, you can by using CloudFormation Macros and Transform


• Is every AWS Service supported?

         - Almost. Only a select few niches are not there yet

         - You can work around that using CloudFormation Custom Resources

         - Usually when there is a new feature of AWS, the CloudFormation update to support the feature comes very, very soon 








======================================================== AWS CLOUDFORMATION MAPPINGS =========================================================



• Mappings are fixed variables within your CloudFormation template

• They’re very handy to differentiate between different environments (dev vs prod), regions (AWS regions), AMI types...

• All the values are hardcoded within the template



EG : 

Mappings: 
  Mapping01: 
    Key01: 
      Name: Value01
    Key02: 
      Name: Value02
    Key03: 
      Name: Value03





RegionMap: 
    us-east-1:
      HVM64: ami-0ff8a91507f77f867
      HVMG2: ami-0a584ac55a7631c0c
    us-west-1:
      HVM64: ami-0bdb828fd58c52235
      HVMG2: ami-066ee5fd4a9ef77f1
    eu-west-1:
      HVM64: ami-047bb4163c506cd98
      HVMG2: ami-0a7c483d527806435
    ap-northeast-1:
      HVM64: ami-06cd52961ce9f0d85
      HVMG2: ami-053cdd503598e4a9d
    ap-southeast-1:
      HVM64: ami-08569b978cc4dfa10
      HVMG2: ami-0be9df32ae9f92309


-- So here, based on the region you have, so us-east-1, us-west-1, or eu-west-1, and based on the architecture you're using, for example, HVM64 or HVMG2, this is going to give you a different AMI ID every time.

-- Well, we know that the AMIs are specific based on the region, so of course it makes sense to have a different AMI per region.







------------------------------------------ When would you use Mappings vs. Parameters?



• Mappings are great when you know in advance all the values that can be taken and that they can be deduced from variables such as

    • Region
    • Availability Zone
    • AWS Account
    • Environment (dev vs prod) • etc...


• They allow safer control over the template

• Use parameters when the values are really user specific ,whenever the values are really user specific and you can not predict them ahead of time.







--------------------------------- Accessing Mapping Values (Fn::FindInMap)



• We use Fn::FindInMap to return a named value from a specific key

• !FindInMap [ MapName,TopLevelKey, SecondLevelKey ]


EG :

AWSTemplateFormatVersion: "2010-09-09"
Mappings: 
  RegionMap: 
    us-east-1:
      HVM64: ami-0ff8a91507f77f867
      HVMG2: ami-0a584ac55a7631c0c
    us-west-1:
      HVM64: ami-0bdb828fd58c52235
      HVMG2: ami-066ee5fd4a9ef77f1
    eu-west-1:
      HVM64: ami-047bb4163c506cd98
      HVMG2: ami-0a7c483d527806435
    ap-northeast-1:
      HVM64: ami-06cd52961ce9f0d85
      HVMG2: ami-053cdd503598e4a9d
    ap-southeast-1:
      HVM64: ami-08569b978cc4dfa10
      HVMG2: ami-0be9df32ae9f92309
Resources: 
  myEC2Instance: 
    Type: "AWS::EC2::Instance"
    Properties: 
      ImageId: !FindInMap [RegionMap, !Ref "AWS::Region", HVM64]
      InstanceType: m1.small


-- we have an EC2 instance that is using an ImageId. And this ImageId is using the FindInMap function.

-- to use this FindInMap function, we first need to use a map name. So here we have the RegionMap. Then we have the top level key.

-- So what we want to use in here, we have a reference to the pseudo parameter AWS::Region. So if you launch this template in us-east-1, it's going to be us-east-1, and if you launch it to us-west-1, automatically this pseudo parameter is going to resolve to us-west-1.
 
-- And then finally, the type of architecture you want, for example, HVM64. And this works great because, well, AMIs are region specific, and so you want to make sure you have the right AMI for the right region and the right architecture.







---------------------------------------------- Mappings Hands On



-- we'll use the mapping and we'll see how we can combine it with a parameter to change and deduce values within your templates.

-- So we'll do two things with our mappings. We'll change the instance type of our EC2 instance based on the, on the environment that we're in. And we'll also change the AMI of our EC2 instance based on the region we are in.

-- create yaml file 





Parameters:
  EnvironmentName:
    Description: Environment Name
    Type: String
    AllowedValues: [development, production]
    ConstraintDescription: must be development or production

Mappings:
  AWSRegionArch2AMI:
    af-south-1:
      HVM64: ami-06db08e8636583118
    ap-east-1:
      HVM64: ami-0921e2da2f22f9617
    ap-northeast-1:
      HVM64: ami-06098fd00463352b6
    ap-northeast-2:
      HVM64: ami-07464b2b9929898f8
    ap-northeast-3:
      HVM64: ami-0b96303a469fa0678
    ap-south-1:
      HVM64: ami-0bcf5425cdc1d8a85
    ap-southeast-1:
      HVM64: ami-03ca998611da0fe12
    ap-southeast-2:
      HVM64: ami-06202e06492f46177
    ca-central-1:
      HVM64: ami-09934b230a2c41883
    eu-central-1:
      HVM64: ami-0db9040eb3ab74509
    eu-north-1:
      HVM64: ami-02baf2b4223a343e8
    eu-south-1:
      HVM64: ami-081e7f992eee19465
    eu-west-1:
      HVM64: ami-0ffea00000f287d30
    eu-west-2:
      HVM64: ami-0fbec3e0504ee1970
    eu-west-3:
      HVM64: ami-00dd995cb6f0a5219
    me-south-1:
      HVM64: ami-0502022ce8bfa56a9
    sa-east-1:
      HVM64: ami-0c27c96aaa148ba6d
    us-east-1:
      HVM64: ami-0742b4e673072066f
    us-east-2:
      HVM64: ami-05d72852800cbf29e
    us-west-1:
      HVM64: ami-0577b787189839998
    us-west-2:
      HVM64: ami-0518bb0e75d3619ca
  EnvironmentToInstanceType:
    development:
      instanceType: t2.micro
    # we want a bigger instance type in production
    production:
      instanceType: t2.small

Resources:
  EC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !FindInMap [EnvironmentToInstanceType, !Ref 'EnvironmentName', instanceType]
      # Note we use the pseudo parameter AWS::Region
      ImageId: !FindInMap [AWSRegionArch2AMI, !Ref 'AWS::Region', HVM64]






-- So we have one parameter defined and it's the environment name, it's a string and we allow two values, development and production.

-- now we have the mappings in our CloudFormation template. And this mapping has a first mapping named AWSRegionArch2AMI which is going to map a region  an architecture to an AMI ID.

-- So as we can see, based on the region we're in, we have a different AMI ID.

-- And the second mapping we have defined is an environment to instance type mapping.

-- this one is saying, Hey, if you're in development or production, so these maps, the parameter we have defined right above.

-- So if you're in development then the instance type should be t2 micro. And if you're in production then the instance type should be t2 small.

-- uplaod stack and observe , it will create t2.micro isnatnce coz e are in development 

-- update stack and make into production it will create t2.small








------------------------------- CloudFormation – Pseudo Parameters


• AWS offers us Pseudo Parameters in any CloudFormation template

• These can be used at any time and are enabled by default

• Important pseudo parameters:

    EG ;

    AWS::AccountId

    AWS::Region

    AWS::StackId

    AWS::StackName

    AWS::NotificationARNs

    AWS::NoValue

    AWS::URLSuffix

    AWS::NotificationARNs

    AWS::Partition










======================================================== AWS CLOUDFORMATION OUTPUTS =========================================================



• The Outputs section declares optional outputs values that we can import into other stacks (if you export them first)!

• You can also view the outputs in the AWS Console or in using the AWS CLI

• They’re very useful for example if you define a network CloudFormation, and output the variables such as VPC ID and your Subnet IDs

• It’s the best way to perform some collaboration cross stack, as you let expert handle their own part of the stack




-------------------------- CloudFormation – Outputs Example

• Creating a SSH Security Group as part of one template

• We create an output that references that security group


Outputs:
  StackSSHSecurityGroup:
    Description: The SSH SG
    Value: !Ref MycompanywideSShSG
    Export:
      Name: SSH SecurityGroup



-------------------------- CloudFormation – Outputs Hands On



• Creating a SSH Security Group as part of one template

• We create an output that references that security group


Outputs:
  StackSSHSecurityGroup:
    Description: The SSH SG
    Value: !Ref MycompanywideSShSG
    Export:
      Name: SSH SecurityGroup






-- create one yaml file 



Resources:
  # here we define a SSH security group that will be used in the entire company
  MyCompanyWideSSHSecurityGroup:
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-security-group.html
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable SSH access via port 22
      SecurityGroupIngress:
        # we have a lot of rules because it's a perfect security group
        # finance team network
      - CidrIp: 10.0.48.0/24
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22
        # marketing team network
      - CidrIp: 10.0.112.0/24
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22
        # application team support network
      - CidrIp: 10.0.176.0/24
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22

Outputs:
  StackSSHSecurityGroup:
    Description: The SSH Security Group for our Company
    Value: !Ref MyCompanyWideSSHSecurityGroup
    Export:
      Name: SSHSecurityGroup




-- deploy stacj in CF and see the SG group will created and also check output section in CF Console we have o/p with name SSHSecurityGroup as export name 

IMP : the outputs that are exported have to be unique within your CloudFormation account on the region, 

-- if you upload the same template again u will get an error









-------------------------- CloudFormation – Outputs Cross-Stack Reference


• We then create a second template that leverages that security group

• For this, we use the Fn::ImportValue function

• You can’t delete the underlying stack until all the references are deleted





-------------------------- CloudFormation – Outputs Cross-Stack Reference - Hands On


create one yaml file 



Parameters:  
  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Resources:
  MySecureInstance:
    # http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-ec2-instance.html
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref ImageId
      InstanceType: t2.micro
      SecurityGroups:
        # we reference the output here, using the Fn::ImportValue function
        - !ImportValue SSHSecurityGroup



-- here we are importing the SSHSecurityGroup from the previous stack , note: name should be unique and match correctly

-- create new stack and deploy stack , it will create ec2 instance and that instance will get security group from the cross stack coz we are importing the security group from different stack 

-- now delete first stack , u will get an error coz u have to first delete the underlying infrastructure i.e. delete the recent stack where u import the value then delete the first stack









======================================================== AWS CLOUDFORMATION CONDITIONS =========================================================




• Conditions are used to control the creation of resources or outputs based on a condition

• Conditions can be whatever you want them to be, but common ones are:
   • Environment (dev / test / prod) 
   • AWS Region
   • Any parameter value

• Each condition can reference another condition, parameter value or mapping





-------------------------- How to define a Condition



-- So, you have a conditions block and you create the condition name and then you apply a statement, logical statement.

-- for eg:

  Conditions:
     CreateprodResource: !Equals [!Ref EnvType, prod]
  

- we have the equals function that tests whether or not the parameter environment type is matching the word prod.



• The logical ID is for you to choose. It’s how you name condition

• The intrinsic function (logical) can be any of the following:

   • Fn::And
   • Fn::Equals
   • Fn::If
   • Fn::Not
   • Fn::Or






----------------- How to use a Condition

• Conditions can be applied to resources / outputs / etc...


Resources:
  EC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref ImageId
      InstanceType: t2.micro
      
  MountPoint:
    Type: AWS::EC2::VolumeAttachment
    Condition: CreateProdResources
    Properties:
      InstanceId:
        !Ref EC2Instance
      VolumeId:
        !Ref NewVolume
      Device: /dev/sdh








-------------------------- Intrinsic Functions – Fn::GetAtt



• Attributes are attached to any resources you create and unfortunately not every attribute exists for every resource. for eg we have ref and Get for ec2 instance and not for ec2 volume (check in documentation for more clarity)

-- So the best way to know which attributes exist for your resources is the documentation.





-- The following example template returns the SourceSecurityGroup.OwnerAlias and SourceSecurityGroup.GroupName of the load balancer with the logical name myELB.


EG 

AWSTemplateFormatVersion: 2010-09-09
Resources:
  myELB:
    Type: AWS::ElasticLoadBalancing::LoadBalancer
    Properties:
      AvailabilityZones:
        - eu-west-1a
      Listeners:
        - LoadBalancerPort: '80'
          InstancePort: '80'
          Protocol: HTTP
  myELBIngressGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: ELB ingress group
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          SourceSecurityGroupOwnerId: !GetAtt myELB.SourceSecurityGroup.OwnerAlias
          SourceSecurityGroupName: !GetAtt myELB.SourceSecurityGroup.GroupName



-- in general So anytime we use Ref, we're going to get the reference ID out of it.

-- But if we use GetAtt to get an attribute, we have the option to get more information out of this EC2 instance. So here we have the AvailabilityZone. So for example, we can know in which AZ an instance was launched, for example, us-east-1b. You get the Id again,

-- you could get the PrivateDNSName, the PrivateIp, the PublicDNSName, and the PublicIp. So while the Ref gives you usually a reference to the ID of the resource you have created, the GetAtt allows you to get more out of the resource and you can only get what CloudFormation supports in terms of attributes that are defined in documentation








--------------------------------------- condition Hands On


create yaml file 




Parameters:  
  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

  EnvType:
    Description: Environment type.
    Default: test
    Type: String
    AllowedValues:
      - prod
      - test
    ConstraintDescription: must specify prod or test.

Conditions:
  CreateProdResources: !Equals [ !Ref EnvType, prod ]

Resources:
  EC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref ImageId
      InstanceType: t2.micro
      
  MountPoint:
    Type: AWS::EC2::VolumeAttachment
    Condition: CreateProdResources
    Properties:
      InstanceId:
        !Ref EC2Instance
      VolumeId:
        !Ref NewVolume
      Device: /dev/sdh

  NewVolume:
    Type: AWS::EC2::Volume
    Condition: CreateProdResources
    Properties:
      Size: 1
      AvailabilityZone:
        !GetAtt EC2Instance.AvailabilityZone

Outputs:
  VolumeId:
    Condition: CreateProdResources
    Value:
      !Ref NewVolume





-- So it has two parameters. One is "ImageId" to get the latest image ID for Amazon Linux 2, and then we have the "EnvType", environment type.

-- So we have created a Condition right here called "CreateProdResources". And then we are checking for the equality of the parameter "EnvType" to the value "prod".

-- So if we select "prod" for the "EnvType", then this is going to be true. And if we are selecting "test", then this is going to be false.

-- And from that condition, then we'll have the creation or not of specific resources within our template.

-- So the EC2Instance we're creating has two properties, the "ImageId" and the "InstanceType", so we are familiar with this. And there are no Conditions attached to the resource here.

-- But we have a "MountPoint", which is an EC2 VolumeAttachment, to attach an EBS volume onto our EC2Instance.

-- So only in "prod" will we have this VolumeAttachment

-- And if you look at the NewVolume itself, well, it is an EC2 Volume, again that is being conditioned by this Condition named "CreateProdResources".

-- we can see that we use Conditions on resources, but also on outputs.



-- deploy this stack in console with test environment, it will creta eone ec2 as a part of templte 

-- now update and change to prod , we have two new resources , the "MountPoint" and the "NewVolume".

-- So the NewVolume has been created. So this is an EBS Volume, and it is right here, of size 1GB, and it is in use, and it's actually already attached to my EC2Instance.









======================================================== AWS CLOUDFORMATION RULES =========================================================




-- rules are very exciting, because parameters are quite limited in their ability to be validated.

-- parameters are quite limited in their ability to be validated. So we can have some constraints within a single parameter. For example, checking its type, the Min/MaxLength, the Min/MaxValue, AllowedValues or AllowedPatterns.

-- But if we want to do cross validation of all parameters we can use rules.

-- rules are used to perform the parameter validation based on the values of other parameters (cross-parameter validation)

-- For example, we can ensure that all subnets selected within the parameters are within the same VPC,

-- This is something that we cannot do with just parameters alone, we need to use rules for that.

-- So the way it works that's we define our templates our parameters, and our rules.

-- We will create an update in CloudFormation. That CloudFormation will perform a check of the parameters against the rules.And if it's not valid, then CloudFormation will not proceed with the updates or the creates, it will be failed.

-- So defining a rule is not really easy 

-- CloudFormation Rule consists of an optional rule condition and one or more assertion




EG:




Rules:
  ProdInstanceType:
    RuleCondition: !Equals 
      - !Ref Environment
      - prod
    Assertions:
      - Assert:
          !Equals [t2.small, !Ref InstanceType]
        AssertDescription: 'For a production environment, the instance type must be t2.small'

  DevInstanceType:
    RuleCondition: !Equals 
      - !Ref Environment
      - dev
    Assertions:
      # Assert with Or
      # - Assert:
      #     'Fn::Or':
      #       - !Equals [!Ref InstanceType, t2.nano]
      #       - !Equals [!Ref InstanceType, t2.micro]
      # Assert with Contains
      - Assert:
          'Fn::Contains':
            - - t2.nano
              - t2.micro
            - !Ref InstanceType
        AssertDescription: 'For a development environment, the instance type must be t2.nano or t2.micro'
  





1 So each rule consists of a condition. And so to determine whether or not the rule takes effect or assertion, so there's only one per rule.

2 we have an assertion. So what is this rule going to assert?

     - it describes what values are Allowed for a particular parameter . Can contain one or more AssertDescription


-- If you do not define a rule condition then the rule's assertion will take effect with every single create and update operation.     





--------------------------- Rules Example 



-- So for example, if you have an application of a balancer and you configure an SSL listener, so you want to make sure that you have HTTPS outside of your ALB, then you need to provide us ACM certificate.


-- supported functions


Fn::And

Fn::Contains

Fn::EachMemberEquals

Fn::EachMemberIn

Fn::Equals

Fn::If

Fn::Not

Fn::Or

Fn::RefAll

Fn::ValueOf

Fn::ValueOfAll







------------------------------------------- Rules Hands On



-- we're going to create a CloudFormation template that will check the value of an instance type parameter and also the value of the environment parameter and make sure they match together.

-- create one yaml file 





Parameters:
  InstanceType:
    Type: String
    Default: t2.small
    AllowedValues:
      - t2.nano
      - t2.micro
      - t2.small

  Environment:
    Type: String
    Default: dev
    AllowedValues:
      - dev
      - prod
      
  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Rules:
  ProdInstanceType:
    RuleCondition: !Equals 
      - !Ref Environment
      - prod
    Assertions:
      - Assert:
          !Equals [t2.small, !Ref InstanceType]
        AssertDescription: 'For a production environment, the instance type must be t2.small'

  DevInstanceType:
    RuleCondition: !Equals 
      - !Ref Environment
      - dev
    Assertions:
      # Assert with Or
      # - Assert:
      #     'Fn::Or':
      #       - !Equals [!Ref InstanceType, t2.nano]
      #       - !Equals [!Ref InstanceType, t2.micro]
      # Assert with Contains
      - Assert:
          'Fn::Contains':
            - - t2.nano
              - t2.micro
            - !Ref InstanceType
        AssertDescription: 'For a development environment, the instance type must be t2.nano or t2.micro'
  

Resources:
  MyEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: !Ref ImageId






-- here , we have three parameters. 

      One is instance type, 
      
      the other one is environment, 
      
      and finally, image ID.


-- So the interesting parts goes in the instance types and the environments.      

-- So if we look at instance type, by default, it is a t2 small, and the allowed value is t2 nano, t2 micro and t2 small.

-- And then the environment by default is dev, but we will have value, dev and prod.


IMP :


-- so the logic is that if we are in dev, we want to allow a t2 nano or a t2 micro. And if we are in prod, we only want to allow a t2 small.

-- But this is not something we can do just with parameters.

-- So we have to go and use a rule.

-- So let's create a rule called ProdInstanceType,and the rule has a rule condition to be evaluated or not.

-- So this ProdInstanceType is going to be evaluated only when the environment is equal to prod.

-- this rule is only checking the ProdInstanceType, so only do it when the environment is prod.

-- there's only one assertion, because there's only one minus sign here.(yaml code) And so it's going to assert one thing

-- so it's going to assert one thing which is that t2 small is equal to the instance type.

-- Now similarly, we have a rule for dev instance type.

-- So we're only having this rule run when the environment is dev. And then for the assertions, there are two ways of writing it.

-- So either we use an or function, or we use a contains function.But they both have the same

-- which is saying, hey, the instance type must be either equal to t2 nano or to t2 micro.

-- deploy stack --> choose dev ---> choose t2.small --> create stack , u will get an error cozz' For development environments, the instance type must be t2 nano or t2 micro,as per rules 

-- for same prod also it must allow t2.small only 

-- now deploy stack with dev --> t2.micro it will create successfully









======================================================== AWS CLOUDFORMATION METADATA =========================================================



-- So metadata is just optional and it's for you to include arbitrary YAML to provide details about the templates or resources.

-- The metadata doesn't have an impact around how your CloudFormation template works so far,




---------------------------------- special metadata keys



-- So we have special metadata keys, but some of them are used in AWS and have a special meaning.

1 AWS:CloudFormation:Interface :

      - which allows you to group and order the input parameters when they're displayed in the AWS console.

2 AWS:CloudFormation:Authentication:

      - used to specify Authentication credentials for files or source that you specify in  AWS:CloudFormation:Init.

3 AWS:CloudFormation:Init:

      - Define configuration Tasks for cfn-init , it is the most powerful usage of the metadata






-------------------------------------- AWS:CloudFormation:Interface



-- this allows you to define grouping and ordering of input parameters, when they are displayed in the AWS Console.

-- This is meant when user must input template parameters manually

-- You provide them with grouping and sorting and then they're allowed to put parameters efficiently.

-- For example, if you have a bunch of parameters related to EC2 instances, may be we group them together.(group all the ec2 related parameter together)



-- create one yaml file 





Parameters:
  InstanceType:
    Description: EC2 instance type.
    Type: String
    Default: t2.micro
    AllowedValues:
    - t2.micro
    - t2.small
    - t2.medium
    - m3.medium
    - m3.large
    - m3.xlarge
    - m3.2xlarge
  SubnetID:
    Description: Subnet ID
    Type: AWS::EC2::Subnet::Id
  SecurityGroupID:
    Description: Security Group
    Type: AWS::EC2::SecurityGroup::Id

Resources:
  MyEC2Instance:
    Type: AWS::EC2::Instance
    Properties:
      AvailabilityZone: us-east-1a
      ImageId: ami-0742b4e673072066f
      InstanceType: !Ref InstanceType
      SecurityGroups:
        - !Ref SecurityGroupID
      SubnetId: !Ref SubnetID

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Network Configuration"
        Parameters:
          - SubnetID
          - SecurityGroupID
      - Label:
          default: "Amazon EC2 Configuration"
        Parameters:
          - InstanceType
    ParameterLabels:
      SubnetID:
        default: "Which subnet should this be deployed to?"





-- So we have a few parameters. We have the InstanceType, which is going to allow us to select an EC2 instance type.

-- We have the SubnetID to choose the EC2 Subnet ID, as well as the SecurityGroupID for our EC2 instance.

-- So we defined some metadata with some CloudFormation::Interface and we are defining ParameterGroups.

        - ParameterGroup is a property of the AWS::CloudFormation::Interface resource that defines a parameter group and the parameters to include in the group.

        - parameter Labels are friendly names that the AWS CloudFormation console displays instead of the logical IDs.


-- So the first one is going to be called Network Configuration and within its we are defining a few parameters which is SubnetID and SecurityGroupID.        

-- deploy the stack and observe the User Interface

-- for Subnet ID, as you can see, there is a question, a new label, which is, Which subnet should this be deployed to? which is a much nicer way of defining your parameters and so on.

-- So this is just to enhance the UI in case you expect users to use the Console a lot to deploy your CloudFormation templates and using this you can make them more user-friendly.








======================================================== AWS CLOUDFORMATION CFN INIT AND USERDATA =========================================================



------------------------------------------ So what is that?



-- Well, many of the CloudFormation templates we have so far are about provisioning computing resources in your cloud. That means EC2 instances, or auto-scaling groups, et cetera, et cetera,

-- you just don't want to just provision the EC2 instances. Sometimes you want these instances to be self configured so that they can perform the job they're supposed to do.

-- so you can fully automate your EC2 instances fleet state with CloudFormation init.




------------------------------------------ User Data in EC2 for CloudFormation


• We can have user data at EC2 instance launch through the console

• Let’s learn how to write the same EC2 user-data script in our CloudFormation template

• The important thing to pass is the entire script through the function Fn::Base64

• Good to know, user data script log is in /var/log/cloud-init-output.log




------------------------------------------ User Data in EC2 for CloudFormation Hands On



create one yaml file 





Parameters:
  KeyName:
    Description: Name of an existing EC2 key pair for SSH access to the EC2 instance.
    Type: AWS::EC2::KeyPair::KeyName

  SSHLocation:
    Description: The IP address range that can be used to SSH to the EC2 instances
    Type: String
    MinLength: '9'
    MaxLength: '18'
    Default: 0.0.0.0/0
    AllowedPattern: "(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})\\.(\\d{1,3})/(\\d{1,2})"
    ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x.

  ImageId:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2

Resources:
  WebServer:
    Type: AWS::EC2::Instance
    Properties:
      ImageId: !Ref ImageId
      InstanceType: t2.micro
      KeyName: !Ref KeyName
      SecurityGroups:
        - !Ref WebServerSecurityGroup
      UserData:
        Fn::Base64: |
           #!/bin/bash
           yum update -y
           amazon-linux-extras install -y lamp-mariadb10.2-php7.2 php7.2
           yum install -y httpd mariadb-server
           systemctl start httpd
           systemctl enable httpd
           usermod -a -G apache ec2-user
           chown -R ec2-user:apache /var/www
           chmod 2775 /var/www
           find /var/www -type d -exec sudo chmod 2775 {} \;
           find /var/www -type f -exec sudo chmod 0664 {} \;
           echo "<?php phpinfo(); ?>" > /var/www/html/phpinfo.php

  WebServerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: "Enable HTTP access via port 80 + SSH access"
      SecurityGroupIngress:
      - CidrIp: 0.0.0.0/0
        FromPort: 80
        IpProtocol: tcp
        ToPort: 80
      - CidrIp: !Ref SSHLocation
        FromPort: 22
        IpProtocol: tcp
        ToPort: 22




-- So we have key names.This is to provide an SSH key is a certification key which is going to provide a CIDR to allow SSH into the instance 

-- image ID to get the latest AMI directly from the parameter storage of AWS.

-- the important part is user data. So you set it out. It needs to have a base 64 inputs. So we use this function FN based 64 and then this vertical pipe is not an error. It is actually needed.

-- what this vertical pipe is doing is saying that everything underneath is going to be a multiline string. So this represents a multiline string.

-- deploy the stack , This is going to create one as a site security group, and then this is going to create a, these to instance.

-- regardless if the script works or not we are still going to get create successful for user data.


IMP :

-- I copy the IP address and go to it, we see the site cannot be reached. So the EC2UserData that script has not finished running yet the CloudFormation templates give us a create complete.

-- connect to your instance --> sudo su --> cat /var/log/cloud-init-output.log

-- this file represents all the outputs of your EC2UserData scripts.

-- So as we can see in here, everything that was passed as commands are being run in here and you can see the outputs of the EC2UserData scripts, which is quite easy quite easy if you are doing some debugging.






------------------------------------------ The Problems with EC2 User Data


• What if we want to have a very large instance configuration?
 
       - it may not fit in the EC2 user data because you're limited in terms of size to be passed to the scripts.

• What if we want to evolve the state of the EC2 instance without terminating it and creating a new one?

• How do we make EC2 user-data more readable?

• How do we know or signal that our EC2 user-data script completed successfully?



---- All these things are addressed by CloudFormation Init.

• Enter CloudFormation Helper Scripts!

     • Python scripts, that come directly on Amazon Linux AMIs, or can be installed using yum or dnf on non-Amazon Linux AMIs

     • cfn-init, cfn-signal, cfn-get-metadata, cfn-hup


-- cfn-init :

           - it's used to retrieve and interpret the resource metadata, installing packages, creating files, and starting services.

-- cfn-signal :

           - which is a wrapper script to signal with a CreationPolicy or a WaitCondition. That means that the EC2 instance will be able to say, to CloudFormation back whether or not it has been successfully created or not.


-- cfn-get-metadata :

           - is a wrapper script to make it easy to retrieve all metadata defined for a resource or a specific path.


-- cfn-hup:

          - a daemon to check for updates to the metadata section in your CloudFormation templates and execute custom hooks when the changes are detected.


-- Usal Flow :    cfn-init ,then cfn-signal then optionally cfn-hup








------------------------------------------ AWS::CloudFormation::Init 



